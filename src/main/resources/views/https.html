{% extends "template.html" %}
{% block main %}

<p>It's often useful to be able to start a server with a self-signed cert. The following code starts a web-server
on HTTPS port 9443 with a simple handler:</p>

{{ source("HttpsSelfSignedCert.java") | raw }}

<h2>Signed certificates</h2>

<p>To use a signed certificate, you need to create an <code>SSLContext</code> and pass it to the <code>withHttpsConfig</code>
    method on the {{ javadoc("io.muserver.MuServerBuilder") | raw }} class.</p>

<p>The {{ javadoc("io.muserver.SSLContextBuilder") | raw }} has a number of useful ways to create a context, for
example you can load a cert from the file system, classpath, or an <code>InputStream</code>.</p>

{{ source("HttpsWithCert.java") | raw }}

<h2>Changing certs at runtime</h2>

<p>To perform a hot change of an HTTPS certificate, construct a new SSLContext and change it using the MuServer
server reference:</p>

<pre><code class="language-java">server.changeSSLContext(sslContext);</code></pre>

<h2>HSTS Handler</h2>

<p>HTTP Strict-Transport-Security instructs browsers to only access your website via HTTPS. This is achieved
by setting the <code>Strict-Transport-Security</code> response header.</p>

<p>For convenience, the {{ javadoc("io.muserver.handlers.HttpsRedirectorBuilder") | raw }} class can be used
to generate a handler to do this for you. Just tell it the HTTPS port to redirect to, and the amount of time
the directive is valid for.</p>

{{ source("HSTSExample.java") | raw }}

<p>If you omit the HSTS config on this builder, it will redirect to HTTPS without setting HSTS headers.</p>

<h2>Let's Encrypt integration</h2>

<p>Getting free, automatically renewed certificates with Let's Encrypt and other ACME-based Certificate
Authorities is even simpler than providing your own SSL config.</p>
<p>See the <a href="/letsencrypt">Let's Encrypt integration documentation</a> for details.</p>

{% endblock %}